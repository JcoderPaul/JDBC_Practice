****** Class Proxy ******

public class Proxy extends Object
                   implements Serializable

Библиотеки, пакты и классы: java.lang.Object
                                 java.lang.reflect
                                      java.lang.reflect.Proxy

Все реализуемые интерфейсы: Serializable

Proxy предоставляет статические методы для создания динамических
прокси-классов и экземпляров, а также является надклассом всех
динамических прокси-классов, созданных этими методами.

Чтобы создать прокси для некоторого интерфейса Foo:

***********************************************************************************
InvocationHandler handler = new MyInvocationHandler(...);
     Class proxyClass = Proxy.getProxyClass(
         Foo.class.getClassLoader(), new Class[] { Foo.class });
     Foo f = (Foo) proxyClass.
         getConstructor(new Class[] { InvocationHandler.class }).
         newInstance(new Object[] { handler });
***********************************************************************************

или проще:

***********************************************************************************
Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
                                     new Class[] { Foo.class },
                                     handler);
***********************************************************************************

Динамический прокси-класс (далее именуемый просто прокси-классом) — это класс,
который реализует список интерфейсов, указанных во время выполнения при создании
класса, с поведением, описанным ниже.

Прокси-интерфейс — это такой интерфейс, который реализуется прокси-классом.

Экземпляр прокси — это экземпляр класса прокси.

Каждый экземпляр прокси имеет связанный с ним объект обработчика вызова, который
реализует интерфейс InvocationHandler. Вызов метода на экземпляре прокси через
один из его интерфейсов прокси будет отправлен методу вызова обработчика вызова
экземпляра, передавая экземпляр прокси, объект java.lang.reflect.Method,
идентифицирующий вызванный метод, и массив типа Object, содержащий аргументы.
Обработчик вызова обрабатывает закодированный вызов метода соответствующим образом,
и результат, который он возвращает, будет возвращен как результат вызова метода
в экземпляре прокси.

****** Прокси-класс имеет следующие свойства:

- Прокси-классы являются общедоступными, окончательными и не абстрактными.
- Неполное имя прокси-класса не указано. Однако пространство имен классов,
  начинающихся со строки "$Proxy", должно быть зарезервировано для
  прокси-классов.
- Класс прокси расширяет java.lang.reflect.Proxy.
- Прокси-класс реализует именно те интерфейсы, которые были указаны при
  его создании, в том же порядке.
- Если прокси-класс реализует непубличный интерфейс, он будет определен
  в том же пакете, что и этот интерфейс. В противном случае пакет
  прокси-класса также не указан. Обратите внимание, что запечатывание
  пакета не помешает успешному определению прокси-класса в конкретном
  пакете во время выполнения, равно как и классы, уже определенные тем
  же загрузчиком классов и тем же пакетом с определенными подписчиками.
- Поскольку прокси-класс реализует все интерфейсы, указанные при его
  создании, вызов getInterfaces для его объекта класса вернет массив,
  содержащий тот же список интерфейсов (в порядке, указанном при его
  создании), вызов getMethods для его объекта класса вернет массив
  объектов Method, который включает все методы в этих интерфейсах, и
  вызов getMethod найдет методы в прокси-интерфейсах, как и ожидалось.
- Метод Proxy.isProxyClass вернет true, если ему будет передан
  прокси-класс — класс, возвращенный Proxy.getProxyClass, или класс объекта,
  возвращенный Proxy.newProxyInstance, — и false в противном случае.
- java.security.ProtectionDomain прокси-класса такой же, как у системных
  классов, загружаемых загрузчиком классов начальной загрузки, например
  java.lang.Object, поскольку код для прокси-класса генерируется доверенным
  системным кодом. Этому домену защиты обычно предоставляется
  java.security.AllPermission.
- Каждый класс прокси имеет один общедоступный конструктор, который
  принимает один аргумент, реализацию интерфейса InvocationHandler,
  для установки обработчика вызова для экземпляра прокси. Вместо
  использования Reflection API для доступа к общедоступному конструктору
  можно также создать экземпляр прокси, вызвав метод Proxy.newProxyInstance,
  который объединяет действия вызова Proxy.getProxyClass с вызовом
  конструктора с обработчиком вызова.

****** Экземпляр прокси имеет следующие свойства:

- Учитывая прокси-экземпляр прокси и один из интерфейсов,
  реализованных его прокси-классом Foo, следующее выражение
  вернет true:
  ****************************************************
  proxy instanceof Foo
  ****************************************************
  и следующая операция приведения будет выполнена успешно
  (вместо создания ClassCastException):
  ****************************************************
  (Foo) proxy
  ****************************************************

- Каждый экземпляр прокси имеет связанный с ним обработчик вызова,
  который был передан его конструктору. Статический метод
  Proxy.getInvocationHandler вернет обработчик вызова, связанный с
  экземпляром прокси, переданным в качестве его аргумента.
- Вызов метода интерфейса на экземпляре прокси будет закодирован и
  отправлен методу вызова обработчика вызова, как описано в
  документации для этого метода.
- Вызов методов hashCode, equals или toString, объявленных в
  java.lang.Object на экземпляре прокси, будет закодирован и
  отправлен методу вызова обработчика вызова таким же образом,
  как кодируются и отправляются вызовы методов интерфейса,
  как описано выше. Классом объявления объекта Method, переданного
  для вызова, будет java.lang.Object. Другие общедоступные методы
  экземпляра прокси, унаследованные от java.lang.Object, не
  переопределяются классом прокси, поэтому вызовы этих методов
  ведут себя так же, как и для экземпляров java.lang.Object.

****** Методы, дублируемые в нескольких прокси-интерфейсах ******

Когда два или более интерфейсов прокси-класса содержат метод с
одинаковым именем и сигнатурой параметра, порядок интерфейсов
прокси-класса становится существенным. Когда такой дублирующий
метод вызывается в экземпляре прокси-сервера, объект метода,
передаваемый обработчику вызова, не обязательно будет тем, чей
объявляющий класс присваивается из ссылочного типа интерфейса,
через который был вызван метод прокси-сервера. Это ограничение
существует из-за того, что соответствующая реализация метода в
сгенерированном прокси-классе не может определить, через какой
интерфейс он был вызван. Следовательно, когда дублирующий метод
вызывается в экземпляре прокси, объект Method для метода в
передовом интерфейсе, который содержит метод (либо напрямую, либо
унаследованный через суперинтерфейс) в списке интерфейсов
прокси-класса, передается методу invoke обработчика вызова,
независимо от типа ссылки в котором произошел вызов метода.

Если прокси-интерфейс содержит метод с тем же именем и сигнатурой
параметра, что и методы hashCode, equals или toString java.lang.Object,
когда такой метод вызывается на экземпляре прокси, объект метода,
передаваемый обработчику вызова, будет иметь java.lang.Object в
качестве его объявляющего класса. Другими словами, общедоступные,
не окончательные методы java.lang.Object логически предшествует всем
прокси-интерфейсам для определения того, какой объект метода передать
обработчику вызова.

Обратите также внимание, что когда дублирующий метод отправляется
обработчику вызова, метод invoke может выдавать только проверенные
типы исключений, которые могут быть назначены одному из типов
исключений в предложении throws метода во всех прокси-интерфейсах,
через которые он может быть вызван. Если метод invoke выдает
проверенное исключение, которое не может быть присвоено ни одному
из типов исключений, объявленных методом в одном из прокси-интерфейсов,
через которые он может быть вызван, то при вызове экземпляра прокси
будет выдано непроверенное исключение UndeclaredThrowableException.
Это ограничение означает, что не все типы исключений, возвращаемые
вызовом getExceptionTypes для объекта метода, переданного методу
invoke, обязательно могут быть успешно вызваны методом invoke.

****** Поля и константы ******

protected InvocationHandler	h - обработчик вызова для этого
                                экземпляра прокси.
****** Конструктор ******

protected Proxy(InvocationHandler h) - создает новый экземпляр Proxy из
                                       подкласса (обычно это динамический
                                       класс прокси) с указанным значением
                                       для его обработчика вызова.

****** Методы ******

---------------------------------------------------------------------------------------------------------
- static InvocationHandler getInvocationHandler(Object proxy) - Возвращает обработчик вызова для
                                                                указанного экземпляра прокси, где proxy -
                                                                экземпляр прокси, чтобы вернуть обработчик
                                                                вызова

---------------------------------------------------------------------------------------------------------

- static Class<?>	getProxyClass(ClassLoader loader,
                                  Class<?>... interfaces) - Возвращает объект java.lang.Class для
                                  прокси-класса с заданным загрузчиком классов и массивом интерфейсов.
                                  Прокси-класс будет определен указанным загрузчиком классов и будет
                                  реализовывать все предоставленные интерфейсы. Если загрузчик классов
                                  уже определил прокси-класс для той же перестановки интерфейсов, то
                                  будет возвращен существующий прокси-класс;
                                  в противном случае прокси-класс для этих интерфейсов будет сгенерирован
                                  динамически и определен загрузчиком классов.
                                  Здесь: loader - загрузчик класса для определения прокси-класса;
                                         interfaces - список интерфейсов для реализации прокси-класса;

Есть несколько ограничений на параметры, которые могут быть переданы в Proxy.getProxyClass:

- Все объекты класса в массиве интерфейсов должны представлять интерфейсы, а не классы или примитивные типы.
- Никакие два элемента в массиве интерфейсов не могут ссылаться на одинаковые объекты класса.
- Все типы интерфейсов должны быть видны по имени через указанный загрузчик классов. Другими словами, для
  загрузчика классов 'cl' и каждого интерфейса 'i' должно выполняться следующее выражение:

  Class.forName(i.getName(), false, cl) == i

- Все непубличные интерфейсы должны быть в одном пакете; в противном случае прокси-класс не смог
  бы реализовать все интерфейсы, независимо от того, в каком пакете он определен.
- Для любого набора методов-членов указанных интерфейсов, имеющих одинаковую сигнатуру:
        - Если тип возвращаемого значения любого из методов является типом примитива или пустым,
          то все методы должны иметь один и тот же тип возвращаемого значения.
        - В противном случае один из методов должен иметь тип возвращаемого значения, назначаемый
          всем типам возвращаемого значения остальных методов.
- Результирующий прокси-класс не должен превышать никаких ограничений, наложенных на классы виртуальной
  машиной. Например, виртуальная машина может ограничить количество интерфейсов, которые может реализовать
  класс, до 65535; в этом случае размер массива интерфейсов не должен превышать 65535.

Если любое из этих ограничений будет нарушено, Proxy.getProxyClass выдаст исключение
IllegalArgumentException. Если аргумент массива интерфейсов или любой из его элементов
имеет значение null, будет выдано исключение NullPointerException.

Обратите внимание, что порядок указанных прокси-интерфейсов имеет значение: два запроса
прокси-класса с одной и той же комбинацией интерфейсов, но в другом порядке, приведут к
двум различным прокси-классам.

---------------------------------------------------------------------------------------------------------

- static boolean isProxyClass(Class<?> cl) - Возвращает true тогда и только тогда, когда указанный класс
                                             был динамически сгенерирован как прокси-класс с использованием
                                             метода getProxyClass или метода newProxyInstance.
                                             Надежность этого метода важна для возможности использовать его
                                             для принятия решений по безопасности, поэтому его реализация не
                                             должна просто проверять, расширяет ли рассматриваемый класс Proxy.
                                             Здесь cl - класс для тестирования

---------------------------------------------------------------------------------------------------------

- static Object newProxyInstance(ClassLoader loader,
                                 Class<?>[] interfaces,
                                 InvocationHandler h) - Возвращает экземпляр прокси-класса для указанных
                                                        интерфейсов, который отправляет вызовы методов
                                                        указанному обработчику вызовов.
Здесь: loader - загрузчик класса для определения прокси-класса;
       interfaces - список интерфейсов для реализации прокси-класса;
       h - обработчик вызова для отправки вызовов метода;

Этот метод эквивалентен:

********************************************************************************************************
Proxy.getProxyClass(loader, interfaces).
                    getConstructor(new Class[] { InvocationHandler.class }).
                    newInstance(new Object[] { handler });
********************************************************************************************************

Proxy.newProxyInstance генерирует исключение IllegalArgumentException
по тем же причинам, что и Proxy.getProxyClass.

Возможные исключения:
IllegalArgumentException - при нарушении любого из ограничений на параметры,
                           которые могут быть переданы в getProxyClass
NullPointerException - если аргумент массива интерфейсов или любой из его
                       элементов имеет значение null, или если обработчик
                       вызова, h, имеет значение null

********************************************************************************************************
См. более подробно документацию:
https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html
********************************************************************************************************

****** Еще немного о прокси с примерами ******

Прокси — это шаблон проектирования. Мы создаем и используем его для добавления и изменения
функционала уже существующих классов. В таком случае, прокси-объект применяется вместо
исходного. Обычно он использует тот же метод, что и оригинальный, и в Java прокси-классы
расширяют исходные. Прокси может вызвать метод исходного объекта, так как у него есть
дескриптор оригинала.

Таким образом, прокси-классы удобно реализуют многие вещи, например:
- логирование старта и остановки метода;
- дополнительную проверку аргументов;
- имитацию поведения исходного класса;
- реализацию отложенной инициализации затратных ресурсов;

Все это происходит без изменений оригинального кода класса. Полный список не ограничивается
примерами выше, они лишь его малая часть.

На практике, прокси-класс напрямую не реализует функционал. Следуя принципу единственной
ответственности, прокси-класс непосредственно выполняет только проксирование, а изменение
поведения реализуется в обработчиках. При вызове прокси-объекта вместо исходного, сам прокси
решает, вызвать ли оригинальный метод или какие-то обработчики. Обработчик может выполнить
как собственную задачу, так и обратиться к оригинальному методу.

Как этим пользоваться в нашем коде?

Самое простое — использовать java.lang.reflect.Proxy, который является частью JDK.
Этот класс может создать прокси-класс или напрямую его инстанс. Пользоваться прокси,
встроенным в Java, очень просто. Все что нужно — реализовать java.lang.InvocationHandler,
чтобы прокси-объект мог его вызывать. Интерфейс InvocationHandler крайне прост и
содержит только один метод: invoke().

При его вызове, аргументы содержат проксируемый оригинальный объект, вызванный метод
(как отражение объекта Method) и массив объектов исходных аргументов. Фрагмент кода
ниже демонстрирует применение:

********************************************************************************************************
package proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
public class JdkProxyDemo {
    interface If {
        void originalMethod(String s);
    }
    static class Original implements If {
        public void originalMethod(String s) {
            System.out.println(s);
        }
    }
    static class Handler implements InvocationHandler {
        private final If original;
        public Handler(If original) {
            this.original = original;
        }
        public Object invoke(Object proxy, Method method, Object[] args)
                throws IllegalAccessException, IllegalArgumentException,
                InvocationTargetException {
            System.out.println("BEFORE");
            method.invoke(original, args);
            System.out.println("AFTER");
            return null;
        }
    }
    public static void main(String[] args){
        Original original = new Original();
        Handler handler = new Handler(original);
        If f = (If) Proxy.newProxyInstance(If.class.getClassLoader(),
                new Class[] { If.class },
                handler);
        f.originalMethod("Hallo");
    }
}
********************************************************************************************************

Для вызова оригинального метода исходного объекта, обработчику необходим доступ к нему.
Что не предоставлено реализацией прокси Java. Нам понадобится самостоятельно передать
аргумент инстансу обработчика в коде.

Обратите внимание на объект (обычно с названием proxy), который передается в качестве
аргумента вызываемому обработчику. Это прокси-объект, который отражение Java генерирует
динамически, а не тот объект, что мы хотим проксировать.) Таким образом, мы можем
использовать, как отдельные объекты-обработчики для каждого исходного класса, так и
общий объект, который знает, как вызвать оригинальный объект, если для этого вообще
есть какой-либо метод.

В особом случае, мы можем создать обработчик вызова и прокси интерфейса без оригинального
объекта. Более того, класс для реализации интерфейса в исходном коде — не требуется.
Его реализует динамически созданный прокси-класс.

Если же проксируемый класс не реализует интерфейс, стоит задуматься об использовании
какой-либо иной реализации прокси.

